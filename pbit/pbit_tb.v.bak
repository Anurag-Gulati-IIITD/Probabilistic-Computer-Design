// `timescale 1ns / 1ps
// //////////////////////////////////////////////////////////////////////////////////
// // Company: 
// // Engineer: 
// // 
// // Create Date: 11.02.2024 03:38:29
// // Design Name: 
// // Module Name: pbit_tb
// // Project Name: 
// // Target Devices: 
// // Tool Versions: 
// // Description: 
// // 
// // Dependencies: 
// // 
// // Revision:
// // Revision 0.01 - File Created
// // Additional Comments:
// // 
// //////////////////////////////////////////////////////////////////////////////////

// module pbit_tb();

//     parameter FLOAT_SIZE = 24;
//     parameter INT_SIZE = 8;

//     // Parameters
//     parameter CLK_PERIOD = 0.05; // Clock period in time units
    
//     // Signals
//     reg CLK, RST;
//     reg [INT_SIZE-1: -FLOAT_SIZE] z;
//     wire pbit_val;
    
//     // Instantiate the PBIT module
//     pbit dut(
//         .CLK(CLK),
//         .RST(RST),
//         .z(z),
//         .pbit_val(pbit_val)
//     );
    
//     // Clock generation
//     always #((CLK_PERIOD)/2) CLK = ~CLK;
    
//     // Initial stimulus
//     initial begin
//         // Initialize inputs
//         CLK = 0;
//         RST = 0;
// //        z = 32'h00_000000; // Example input, change as needed
        
// //        // Apply reset
// //        #5 RST = 1;
// //        #5 RST = 0;
        
//         // Provide some stimulus
//         z = 32'b0000_0010_0000_0000_0000_0000_0000_0000;
        
//         #5 RST = 1;
//         #5 RST = 0; // Example input, change as needed
        
//         // Monitor signals
//         $monitor("Time=%0t z=%b pbit_val=%b", $time, z, pbit_val);
        
//         // End simulation
//         #1000;
//         $finish;
//     end
    
// endmodule
`timescale 1ns / 1ps

module pbit_tb();

    parameter FLOAT_SIZE = 24;
    parameter INT_SIZE = 8;

    // Parameters
    parameter CLK_PERIOD = 0.05; // Clock period in time units

    // Signals
    reg CLK, RST;
    reg [INT_SIZE-1: -FLOAT_SIZE] z;
    wire signed [INT_SIZE-1:-FLOAT_SIZE] out1, out2, out3;

    // Define the flattened bitstreams for weights
    reg signed [32*3-1:0] weight1;
    reg signed [32*3-1:0] weight2;
    reg signed [32*3-1:0] weight3;

    // Instantiate the Top_level module
    Top_level #(FLOAT_SIZE, INT_SIZE) dut (
        .CLK(CLK),
        .EN(1), // Always enable for simplicity in this testbench
        .b1(8'h01), // Set bias b1 = +1
        .b2(-8'h01), // Set bias b2 = -1
        .b3(-8'h02), // Set bias b3 = -2
        .weight1(weight1), // Pass the flattened bitstream for the 1st row of J
        .weight2(weight2), // Pass the flattened bitstream for the 2nd row of J
        .weight3(weight3), // Pass the flattened bitstream for the 3rd row of J
        .out1(out1),
        .out2(out2),
        .out3(out3)
    );

    // Clock generation
    always #((CLK_PERIOD)/2) CLK = ~CLK;

    // Initial stimulus
    initial begin
        // Initialize inputs
        CLK = 0;
        RST = 0;

        // Provide some stimulus
        z = 32'b0000_0010_0000_0000_0000_0000_0000_0000;

        // Apply reset
        #5 RST = 1;
        #5 RST = 0;

        // Assign actual values for the J matrix
        weight1 = {32'h0000_0000, 32'hFFFFFFFF, 32'h0000_0002};
        weight2 = {32'hFFFFFFFF, 32'h0000_0000, 32'h0000_0002};
        weight3 = {32'h0000_0002, 32'h0000_0002, 32'h0000_0000};

        // Monitor signals
        $monitor("Time=%0t z=%b out1=%b out2=%b out3=%b", $time, z, out1, out2, out3);

        // End simulation
        #1000;
        $finish;
    end
endmodule